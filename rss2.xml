<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>소소한 행복</title>
    <link>https://wellstyle.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>이곳은 다락방 같은 공간입니다. 시간 날 때 잠깐 올라와서 사색도 하고 좋아하는 것, 관심 있는 것, 필요한 것들을 잘 정리해서 보관하려고 합니다.</description>
    <pubDate>Mon, 20 Apr 2020 13:02:47 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Incoming Webhook으로 Microsoft Teams 채널에 메시지 보내기</title>
      <link>https://wellstyle.github.io/2020/04/20/send-message-to-Microsoft-Teams-with-Incoming-Webhook/</link>
      <guid>https://wellstyle.github.io/2020/04/20/send-message-to-Microsoft-Teams-with-Incoming-Webhook/</guid>
      <pubDate>Mon, 20 Apr 2020 10:38:42 GMT</pubDate>
      <description>
      
        &lt;p&gt;Microsoft Teams의 Incoming Webhook을 사용해서 채널에 메시지 전송하는 방법을 정리&lt;/p&gt;
&lt;h2 id=&quot;채널에-Incoming-Webhook-추가하기&quot;&gt;&lt;a href=&quot;#채널에-Incoming-Webhook-추가하기&quot; class=&quot;headerlink&quot; title=&quot;채널에 Incoming Webhook 추가하기&quot;&gt;&lt;/a&gt;채널에 Incoming Webhook 추가하기&lt;/h2&gt;&lt;p&gt;채널에 Incoming Webhook을 추가하는 방법은 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Webhook을 추가할 채널로 이동하여 상단 네비게이션 바 오른쪽에 &lt;code&gt;(•••)&lt;/code&gt; 모양의 옵션을 클릭&lt;/li&gt;
&lt;li&gt;드롭다운 메뉴에서 &lt;code&gt;커넥터&lt;/code&gt;를 클릭하고 &lt;code&gt;Incoming Webhook&lt;/code&gt;을 검색하여 &lt;code&gt;구성&lt;/code&gt; 버튼을 클릭&lt;/li&gt;
&lt;li&gt;이름을 입력한 후에 &lt;code&gt;만들기&lt;/code&gt; 버튼 클릭 &lt;/li&gt;
&lt;li&gt;다이얼로그에 webhook URL이 나타나면 URL을 복사하여 클립보드에 저장한 다음 &lt;code&gt;완료&lt;/code&gt; 버튼 클릭&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Microsoft Teams의 Incoming Webhook을 사용해서 채널에 메시지 전송하는 방법을 정리</p><h2 id="채널에-Incoming-Webhook-추가하기"><a href="#채널에-Incoming-Webhook-추가하기" class="headerlink" title="채널에 Incoming Webhook 추가하기"></a>채널에 Incoming Webhook 추가하기</h2><p>채널에 Incoming Webhook을 추가하는 방법은 다음과 같다.</p><ol><li>Webhook을 추가할 채널로 이동하여 상단 네비게이션 바 오른쪽에 <code>(•••)</code> 모양의 옵션을 클릭</li><li>드롭다운 메뉴에서 <code>커넥터</code>를 클릭하고 <code>Incoming Webhook</code>을 검색하여 <code>구성</code> 버튼을 클릭</li><li>이름을 입력한 후에 <code>만들기</code> 버튼 클릭 </li><li>다이얼로그에 webhook URL이 나타나면 URL을 복사하여 클립보드에 저장한 다음 <code>완료</code> 버튼 클릭</li></ol><a id="more"></a><h2 id="Incoming-Webhook에-메시지-보내기"><a href="#Incoming-Webhook에-메시지-보내기" class="headerlink" title="Incoming Webhook에 메시지 보내기"></a>Incoming Webhook에 메시지 보내기</h2><p>webhook URL에 POST 메소드로 JSON 페이로드를 요청한다.</p><figure class="highlight json"><figcaption><span>JSON payload</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"@type"</span>: <span class="string">"MessageCard"</span>,</span><br><span class="line">    <span class="attr">"@context"</span>: <span class="string">"http://schema.org/extensions"</span>,</span><br><span class="line">    <span class="attr">"themeColor"</span>: <span class="string">"0076D7"</span>,</span><br><span class="line">    <span class="attr">"summary"</span>: <span class="string">"Larry Bryant created a new task"</span>,</span><br><span class="line">    <span class="attr">"sections"</span>: [&#123;</span><br><span class="line">        <span class="attr">"activityTitle"</span>: <span class="string">"![TestImage](https://47a92947.ngrok.io/Content/Images/default.png)Larry Bryant created a new task"</span>,</span><br><span class="line">        <span class="attr">"activitySubtitle"</span>: <span class="string">"On Project Tango"</span>,</span><br><span class="line">        <span class="attr">"activityImage"</span>: <span class="string">"https://teamsnodesample.azurewebsites.net/static/img/image5.png"</span>,</span><br><span class="line">        <span class="attr">"facts"</span>: [&#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Assigned to"</span>,</span><br><span class="line">            <span class="attr">"value"</span>: <span class="string">"Unassigned"</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Due date"</span>,</span><br><span class="line">            <span class="attr">"value"</span>: <span class="string">"Mon May 01 2017 17:07:18 GMT-0700 (Pacific Daylight Time)"</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Status"</span>,</span><br><span class="line">            <span class="attr">"value"</span>: <span class="string">"Not started"</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="attr">"markdown"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>텍스트 타입의 필드는 마크다운 문법이 자동으로 적용되는데 Plain 텍스트로 적용하고 싶다면 <code>&quot;markdown&quot;: false</code>로 보내면 된다. </p></blockquote><p>curl로 테스트:</p><figure class="highlight shell"><figcaption><span>curl</span></figcaption><table><tr><td class="code"><pre><span class="line">curl -X POST -H 'Content-Type: application/json' \</span><br><span class="line">    -d '&lt;JSON payload&gt;' &lt;YOUR WEBHOOK URL&gt;</span><br></pre></td></tr></table></figure><h3 id="메시지-카드"><a href="#메시지-카드" class="headerlink" title="메시지 카드"></a>메시지 카드</h3><p>요청이 성공하면 채널에 아래 이미지와 같은 메시지가 수신된다.<br><img src="/gallery/2020/04/message-card.png" alt="Message Card"></p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://docs.microsoft.com/en-us/microsoftteams/platform/webhooks-and-connectors/how-to/add-incoming-webhook" rel="external nofollow noopener noreferrer" target="_blank">Post external requests to Teams with incoming webhooks</a></li><li><a href="https://docs.microsoft.com/en-us/microsoftteams/platform/webhooks-and-connectors/how-to/connectors-using" rel="external nofollow noopener noreferrer" target="_blank">Sending messages to connectors and webhooks</a></li></ul>]]></content:encoded>
      
      <comments>https://wellstyle.github.io/2020/04/20/send-message-to-Microsoft-Teams-with-Incoming-Webhook/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Still Fighting It - Ben Folds</title>
      <link>https://wellstyle.github.io/2020/04/19/Still-Fighting-It/</link>
      <guid>https://wellstyle.github.io/2020/04/19/Still-Fighting-It/</guid>
      <pubDate>Sun, 19 Apr 2020 07:28:17 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;And you’re so much like me&lt;br&gt;넌 날 참 많이 닮았구나&lt;br&gt;I’m sorry&lt;br&gt;그래서 미안해&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/kqPwR39VMh0&quot; frameborder=&quot;0&quot; loading=&quot;lazy&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>And you’re so much like me<br>넌 날 참 많이 닮았구나<br>I’m sorry<br>그래서 미안해</p></blockquote><div class="video-container"><iframe src="https://www.youtube.com/embed/kqPwR39VMh0" frameborder="0" loading="lazy" allowfullscreen></iframe></div><a id="more"></a><h3 id="아들과-아버지가-생각나는-노래"><a href="#아들과-아버지가-생각나는-노래" class="headerlink" title="아들과 아버지가 생각나는 노래"></a>아들과 아버지가 생각나는 노래</h3><p>벤 폴즈가 아들 루이스를 생각하며 만든 곡으로 성장을 통해 받게 되는 고통과 아들을 보며 느끼는 감정을 전하고 있다.</p><p>내 아버지와 나, 그리고 내 아들.<br>내 아버지가 나와 같은 생각을 하셨겠구나. 내 아들도 아버지가 되면 내 생각을 하며 아들을 걱정하고 있겠구나.<br>이런 생각하면 아련하고 목이 메인다.</p><blockquote><p>20년쯤 지나서<br>너와 함께 앉아 맥주를 마시게 된다면<br>오늘에 대해 말해줄게<br>내가 너를 들었을 때 모든 것이 달라졌다고<br>고통이었지<br>맑은 날도, 비가 내리는 날도<br>너가 나와 같은 감정을 느꼈다는 걸 알았어<br>다들 알고 있어<br>어른이 된다는 건 아픈 일이라는 걸<br>그래도 다들 견뎌 내<br>다시 여기로 돌아오니 기분이 이상하구나<br>네게 해줄 말이 있어<br>세월이 흘러도<br>우린 계속 싸워야 한다는 걸<br>넌 노력하고 또 노력하겠지, 그리고 어느 날<br>나에게서 멀리 날아가겠지</p><p>- Still Fighting It 가사 중에서</p></blockquote><h3 id="가사-해석"><a href="#가사-해석" class="headerlink" title="가사 해석"></a>가사 해석</h3><div class="video-container"><iframe src="https://www.youtube.com/embed/rQ5QBCR9zG0" frameborder="0" loading="lazy" allowfullscreen></iframe></div><h3 id="이태원-클라쓰-OST"><a href="#이태원-클라쓰-OST" class="headerlink" title="이태원 클라쓰 OST"></a>이태원 클라쓰 OST</h3><p>이 드라마를 통해 이 곡을 처음 알게 되었고, 노래를 부른 이찬솔이 슈퍼밴드에서 팀으로 부른 노래란 것도 알게 되었다.</p><div class="video-container"><iframe src="https://www.youtube.com/embed/fMDfPwXukJc" frameborder="0" loading="lazy" allowfullscreen></iframe></div><h3 id="슈퍼밴드-윤종신-심사평"><a href="#슈퍼밴드-윤종신-심사평" class="headerlink" title="슈퍼밴드 윤종신 심사평"></a>슈퍼밴드 윤종신 심사평</h3><p>윤종신이 “세상은 기본적으로 불행하고, 덜 불행하기 위해 노력하는 게 인생이라고 생각하거든요” 라고 했는데 요즘들어 더 공감이 간다.</p><div class="video-container"><iframe src="https://www.youtube.com/embed/r0RPDfCw2XU" frameborder="0" loading="lazy" allowfullscreen></iframe></div>]]></content:encoded>
      
      <comments>https://wellstyle.github.io/2020/04/19/Still-Fighting-It/#disqus_thread</comments>
    </item>
    
    <item>
      <title>wrk - 간편하고 가벼운 HTTP 벤치마킹 도구</title>
      <link>https://wellstyle.github.io/2020/04/18/wrk-a-HTTP-benchmarking-tool/</link>
      <guid>https://wellstyle.github.io/2020/04/18/wrk-a-HTTP-benchmarking-tool/</guid>
      <pubDate>Sat, 18 Apr 2020 16:06:29 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/wg/wrk&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;wrk&lt;/a&gt;는 HTTP 웹 애플리케이션 벤치마킹 용도로 사용하는 CLI 도구이다.&lt;/p&gt;
&lt;p&gt;설치와 사용법이 간단하고 시스템 리소스를 적게 사용하기 때문에 빠르고 간편하게 사용할 수 있다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="https://github.com/wg/wrk" rel="external nofollow noopener noreferrer" target="_blank">wrk</a>는 HTTP 웹 애플리케이션 벤치마킹 용도로 사용하는 CLI 도구이다.</p><p>설치와 사용법이 간단하고 시스템 리소스를 적게 사용하기 때문에 빠르고 간편하게 사용할 수 있다.</p><a id="more"></a><h2 id="설치와-사용법이-간단하다"><a href="#설치와-사용법이-간단하다" class="headerlink" title="설치와 사용법이 간단하다."></a>설치와 사용법이 간단하다.</h2><h3 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install wrk</span><br></pre></td></tr></table></figure><h3 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wrk -t20 -c200 -d60s http://localhost:8080/http.json</span><br></pre></td></tr></table></figure><ul><li><code>-t20</code>: Thread <code>20</code>개가 실행되어</li><li><code>-c200</code>: HTTP Connection <code>200</code>개를 서버에 연결하고 (각 Thread 별로 10개의 Connection 연결)</li><li><code>-d60s</code>: <code>60초</code>동안 지속적으로 트래픽 발생</li></ul><p>실행 결과:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Running 1m test @ http://localhost:8080/http.json</span><br><span class="line">  20 threads and 200 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency    61.21ms    6.23ms 137.15ms   83.77%</span><br><span class="line">    Req/Sec   164.12     42.84   300.00     69.83%</span><br><span class="line">  196134 requests in 1.00m, 103.06MB read</span><br><span class="line">  Socket errors: connect 0, read 66, write 0, timeout 0</span><br><span class="line">Requests/sec:   3263.40</span><br><span class="line">Transfer/sec:      1.71MB</span><br></pre></td></tr></table></figure><ul><li><code>Latency    61.21ms    6.23ms 137.15ms   83.77%</code>: 응답시간 평균은 <code>61.21ms</code>, 표준편차는 <code>6.23ms</code>, 최대값은 <code>137.15ms</code>, 표준편차 1 범위에 들어가는 확률은 <code>83.77%</code> (Stdev가 낮을수록 +/- Stdev가 높을수록 응답시간이 안정적이라고 볼 수 있음)</li><li><code>196134 requests in 1.00m, 103.06MB read</code>: 1분 동안 <code>196,314</code>번의 요청을 보냈고 <code>103.06MB</code>데이터를 읽음</li><li><code>Reqeusts/sec: 3263.40</code>: 초당 <code>3,263</code>번의 요청을 보내서 응답을 받음</li></ul><h4 id="추가-옵션"><a href="#추가-옵션" class="headerlink" title="추가 옵션"></a>추가 옵션</h4><ul><li><code>-H, --header</code>: HTTP 헤더 추가.  e.g. “User-Agent: wrk”</li><li><code>-s, --script</code>: LuaJIT 스크립트 추가. <a href="https://github.com/wg/wrk/blob/master/SCRIPTING" rel="external nofollow noopener noreferrer" target="_blank">SCRIPTING</a> 참고</li><li><code>--latency</code>: Latency 통계 출력</li><li><code>--timeout</code>: 타임아웃 값 설정. 기본값 2초</li></ul><h2 id="프로그램이-가볍다"><a href="#프로그램이-가볍다" class="headerlink" title="프로그램이 가볍다."></a>프로그램이 가볍다.</h2><p>Thread와 Connection을 늘리면서 <code>top</code>로 프로세스 상태를 확인해 봤다.</p><ul><li><p>top (Thread: 20, Connection: 200 실행 시)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PID    COMMAND      %CPU TIME     #TH  #WQ  #POR MEM    PURG CMPR PGRP</span><br><span class="line">40294  wrk          6.0  00:01.66 21   0    38   3512K  0B   0B   40294</span><br></pre></td></tr></table></figure></li><li><p>top (Thread: 100, Connection: 1,000 실행 시)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PID    COMMAND      %CPU TIME     #TH   #WQ  #POR MEM  PURG CMPR PGRP</span><br><span class="line">45743  wrk          6.9  00:04.04 101   0    118  22M  0B   0B   45743</span><br></pre></td></tr></table></figure></li><li><p>top (Thread: 500, Connection: 5,000 실행 시)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PID    COMMAND      %CPU TIME     #TH   #WQ  #POR MEM   PURG CMPR PGRP</span><br><span class="line">46541  wrk          11.8 00:05.13 501   0    518  285M+ 0B   0B   46541</span><br></pre></td></tr></table></figure></li></ul><p>동시 요청 수를 5,000까지 늘렸을 때 CPU는 10% 대를 유지하였고 메모리는 요청 수에 따라 리니어하게 증가했지만 285M 정도에 그쳤다.</p><p>경험상 LoadRunner, JMeter, nGrinder 등의 성능테스트 도구는 동시 요청 수에 제약이 있거나 많은 리소스를 필요로 하는 것에 비해 wrk의 리소스 사용량은 매우 적다. (혜자다)</p><h2 id="그런데-말입니다"><a href="#그런데-말입니다" class="headerlink" title="그런데 말입니다."></a>그런데 말입니다.</h2><p>사용하다보니 부족한 기능이 보이기 시작했다. (인간의 욕심은 끝이 없고 같은 실수를 반복한다)</p><ul><li>URL 하나만 요청이 가능하네?</li><li>POST 메소드 요청은 보낼 수 없나?</li><li>요청 사이에 delay 시간을 조금 주고 싶은데?</li></ul><p>여기서 끝내야 했는데 사용법에 나온 LuaJIT 스크립트를 사용하면 될 것 같은 느낌이 온다.<br>어? 샘플 스크립트도 있다.<br>근데 막상 원하는 걸 하려는데 잘 안된다.<br>계속 삽집할 것 같은 느낌도 온다.</p><p>삽질이 끝나면 LuaJIT 활용기도 남기겠다.</p>]]></content:encoded>
      
      <comments>https://wellstyle.github.io/2020/04/18/wrk-a-HTTP-benchmarking-tool/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Lua</title>
      <link>https://wellstyle.github.io/2020/04/12/Lua/</link>
      <guid>https://wellstyle.github.io/2020/04/12/Lua/</guid>
      <pubDate>Sun, 12 Apr 2020 07:35:32 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Introduce&quot;&gt;&lt;a href=&quot;#Introduce&quot; class=&quot;headerlink&quot; title=&quot;Introduce&quot;&gt;&lt;/a&gt;Introduce&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;루아(Lua) 프로그래밍 언어는 가벼운 명령형/절차적 언어로, 확장 언어로 쓰일 수 있는 스크립팅 언어를 주 목적으로 설계되었다.&lt;/li&gt;
&lt;li&gt;루아 프로그램은 직접적으로 인터프리트되지 않고, 바이트 코드로 컴파일되어 루아 가상 머신에서 실행 된다.&lt;/li&gt;
&lt;li&gt;루아는 “달”을 의미하는 포르투갈어이다.&lt;/li&gt;
&lt;li&gt;루아는 특히 게임에서 많이 사용된다.&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Introduce"><a href="#Introduce" class="headerlink" title="Introduce"></a>Introduce</h2><ul><li>루아(Lua) 프로그래밍 언어는 가벼운 명령형/절차적 언어로, 확장 언어로 쓰일 수 있는 스크립팅 언어를 주 목적으로 설계되었다.</li><li>루아 프로그램은 직접적으로 인터프리트되지 않고, 바이트 코드로 컴파일되어 루아 가상 머신에서 실행 된다.</li><li>루아는 “달”을 의미하는 포르투갈어이다.</li><li>루아는 특히 게임에서 많이 사용된다.</li></ul><a id="more"></a><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install lua</span></span><br></pre></td></tr></table></figure><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><ul><li>lua를 실행하고 터미널에서 직접 타이핑하면 코드가 인터프리터에 의한 실행됨</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lua</span></span><br><span class="line">Lua 5.3.5  Copyright (C) 1994-2018 Lua.org, PUC-Rio</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">print</span>(<span class="string">"Hello Lua"</span>)</span></span><br><span class="line">Hello Lua</span><br></pre></td></tr></table></figure><ul><li>파일로 코드를 작성하여 실행하는 방법</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">which</span> lua</span></span><br><span class="line">/usr/local/bin/lua</span><br><span class="line"><span class="meta">$</span><span class="bash"> vi hello.lua</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/usr/<span class="built_in">local</span>/bin/lua</span></span><br><span class="line">print("Hello Lua")</span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x hello.lua</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./hello.lua</span></span><br><span class="line">Hello Lua</span><br></pre></td></tr></table></figure><h2 id="Learn-Lua"><a href="#Learn-Lua" class="headerlink" title="Learn Lua"></a>Learn Lua</h2><h3 id="Learn-Lua-in-15-Minutes"><a href="#Learn-Lua-in-15-Minutes" class="headerlink" title="Learn Lua in 15 Minutes"></a>Learn Lua in 15 Minutes</h3><ul><li><a href="http://tylerneylon.com/a/learn-lua/" rel="external nofollow noopener noreferrer" target="_blank">Learn Lua in 15 Minutes</a></li><li><a href="https://roboticist.tistory.com/576" rel="external nofollow noopener noreferrer" target="_blank">(번역본)루아 15분 안에 배우기</a></li></ul><h3 id="Learn-Lua-in-an-Hour"><a href="#Learn-Lua-in-an-Hour" class="headerlink" title="Learn Lua in an Hour"></a>Learn Lua in an Hour</h3><div class="video-container"><iframe src="https://www.youtube.com/embed/S4eNl1rA1Ns" frameborder="0" loading="lazy" allowfullscreen></iframe></div><ul><li><a href="http://tylerneylon.github.io/video-scripts/" rel="external nofollow noopener noreferrer" target="_blank">Video Scripts</a></li></ul><h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><ul><li><a href="https://www.lua.org/" rel="external nofollow noopener noreferrer" target="_blank">공식 웹사이트</a></li><li><a href="https://www.lua.org/cgi-bin/demo" rel="external nofollow noopener noreferrer" target="_blank">웹으로 코드를 실행해 볼 수 있는 페이지</a></li><li><a href="https://ko.wikipedia.org/wiki/%EB%A3%A8%EC%95%84_(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%EC%96%B8%EC%96%B4)" rel="external nofollow noopener noreferrer" target="_blank">위키 - 루아 (프로그래밍 언어)</a></li></ul>]]></content:encoded>
      
      <comments>https://wellstyle.github.io/2020/04/12/Lua/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Cloud Gateway 소개</title>
      <link>https://wellstyle.github.io/2020/04/10/Spring-Cloud-Gateway/</link>
      <guid>https://wellstyle.github.io/2020/04/10/Spring-Cloud-Gateway/</guid>
      <pubDate>Fri, 10 Apr 2020 14:49:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;오픈소스 &lt;code&gt;API Gateway&lt;/code&gt; 솔루션으로 유명한 &lt;code&gt;Spring Cloud Netflix&lt;/code&gt;가 유지보수 모드로 바뀌면서 새로운 대안인 &lt;code&gt;Spring Cloud Gateway&lt;/code&gt;를 소개해 본다.&lt;/p&gt;
&lt;h2 id=&quot;Spring-Cloud-Netflix-유지보수-모드&quot;&gt;&lt;a href=&quot;#Spring-Cloud-Netflix-유지보수-모드&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud Netflix - 유지보수 모드&quot;&gt;&lt;/a&gt;Spring Cloud Netflix - 유지보수 모드&lt;/h2&gt;&lt;p&gt;스프링 클라우드 팀은 &lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-netflix&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Spring Cloud Netflix&lt;/a&gt; 프로젝트가 &lt;code&gt;Eureka&lt;/code&gt;와 &lt;code&gt;concurrency-limits&lt;/code&gt; 모듈을 제외한 나머지 모듈&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;에 대해서 &lt;a href=&quot;https://spring.io/blog/2018/12/12/spring-cloud-greenwich-rc1-available-now#spring-cloud-netflix-projects-entering-maintenance-mode&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;유지보수 모드&lt;/a&gt;&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;에 들어간다고 2018년 12월에 발표했다.&lt;br&gt;대상 모듈에 대해서는 새로운 기능은 추가하지 않고 버그나 보안 이슈에 대해서만 향후 1년 간 지원을 하겠다는 내용이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>오픈소스 <code>API Gateway</code> 솔루션으로 유명한 <code>Spring Cloud Netflix</code>가 유지보수 모드로 바뀌면서 새로운 대안인 <code>Spring Cloud Gateway</code>를 소개해 본다.</p><h2 id="Spring-Cloud-Netflix-유지보수-모드"><a href="#Spring-Cloud-Netflix-유지보수-모드" class="headerlink" title="Spring Cloud Netflix - 유지보수 모드"></a>Spring Cloud Netflix - 유지보수 모드</h2><p>스프링 클라우드 팀은 <a href="https://github.com/spring-cloud/spring-cloud-netflix" rel="external nofollow noopener noreferrer" target="_blank">Spring Cloud Netflix</a> 프로젝트가 <code>Eureka</code>와 <code>concurrency-limits</code> 모듈을 제외한 나머지 모듈<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>에 대해서 <a href="https://spring.io/blog/2018/12/12/spring-cloud-greenwich-rc1-available-now#spring-cloud-netflix-projects-entering-maintenance-mode" rel="external nofollow noopener noreferrer" target="_blank">유지보수 모드</a><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>에 들어간다고 2018년 12월에 발표했다.<br>대상 모듈에 대해서는 새로운 기능은 추가하지 않고 버그나 보안 이슈에 대해서만 향후 1년 간 지원을 하겠다는 내용이다.</p><a id="more"></a><p>그리고 유지보수 모듈을 대체할 수 있는 모듈도 함께 언급했다.</p><table><thead><tr><th>Current</th><th>Replacement</th></tr></thead><tbody><tr><td>Hystrix</td><td><a href="https://github.com/resilience4j/resilience4j" rel="external nofollow noopener noreferrer" target="_blank">Resilience4j</a></td></tr><tr><td>Hystrix Dashboard / Turbine</td><td>Micrometer + Monitoring System</td></tr><tr><td>Ribbon</td><td>Spring Cloud Loadbalancer</td></tr><tr><td>Zuul 1</td><td>Spring Cloud Gateway</td></tr><tr><td>Archaius 1</td><td>Spring Boot external config + Spring Cloud Config</td></tr></tbody></table><h2 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h2><p><a href="https://cloud.spring.io/spring-cloud-gateway/reference/html" rel="external nofollow noopener noreferrer" target="_blank">Reference</a> 사이트에 들어가면 다음과 같은 소개 문구가 보인다.</p><blockquote><p>This project provides an <code>API Gateway</code> built on top of the Spring Ecosystem, including: Spring 5, Spring Boot 2 and <code>Project Reactor</code>. Spring Cloud Gateway aims to provide <code>a simple, yet effective way to route to APIs</code> and provide <code>cross cutting concerns</code> to them such as: security, monitoring/metrics, and resiliency.</p></blockquote><blockquote><p>(번역해 보면) 이 프로젝트는 Spring 5, Spring Boot 2 및 <a href="https://projectreactor.io/" rel="external nofollow noopener noreferrer" target="_blank">Project Reactor</a><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>를 포함하여 스프링 생태계 위에 구축된 <code>API Gateway</code>를 제공합니다. Spring Cloud Gateway의 목표는 <code>간단하지만 효과적인 API 라우팅</code> 방법을 제공하고 보안, 모니터링/메트릭 및 복원력과 같은 <code>횡단 관심사</code><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>를 제공하는 것입니다. </p></blockquote><p><code>API Gateway</code>에서 필요한 <code>API 라우팅</code>과 보안, 모니터링, 복원과 같은 공통 기능을 제공하고 있고 <code>Project Reactor</code>를 사용하여 Non-Blocking 방식의 프로그래밍이 필요해 보인다.</p><h3 id="어떻게-동작하나"><a href="#어떻게-동작하나" class="headerlink" title="어떻게 동작하나?"></a>어떻게 동작하나?</h3><p>다음 다이어그램을 보고 SCG가 어떤 방식으로 동작하는지 살펴보자.</p><p><img src="/gallery/2020/04/spring-cloud-gateway-diagram.png" alt="Spring Cloud Gateway Diagram"></p><ol><li><code>Client</code>가 <code>SCG</code>에 요청</li><li><code>Gateway Handler Mapping</code>은 요청이 <code>route</code>와 일치한다고 판단하면 <code>Gateway Web Handler</code>로 전달</li><li><code>Gateway Web Handler</code>는 요청과 관련된 <code>filter chain</code>을 통해 요청을 실행<ul><li>Filter가 점선으로 구분되는 이유는 프록시 요청이 전송되기 전과 후에 필터 로직을 실행할 수 있기 때문</li></ul></li><li><code>filter chain</code>에 있는 Pre 필터 로직이 실행</li><li>대상 서비스로 프록시 요청을 수행</li><li>프록시 요청이 이루어진 후 <code>Post</code> 필터 로직이 실행</li><li><code>Client</code>에 응답</li></ol><p>개념은 간단하고, 여기에 3가지 용어만 이해하면 된다.</p><h4 id="1-Route-라우트"><a href="#1-Route-라우트" class="headerlink" title="1. Route(라우트)"></a>1. Route(라우트)</h4><ul><li>Client의 요청에 대해 어떤 조건(Predicate)으로 일치하는지 판단하고 어떤 필터(Filter) 로직을 실행하고 어떤 서비스로 프록시 요청을 할지를 SCG에 설정을 해줘야 한다.</li><li>이러한 설정의 기본 단위 블록이 Route이고 ID, 대상 서비스 URI, Predicate 모음 및 Filter 모음으로 정의된다.</li><li>Predicate가 true이면 요청이 해당 route와 일치한다고 판단한다.</li></ul><h4 id="2-Predicate-조건부"><a href="#2-Predicate-조건부" class="headerlink" title="2. Predicate(조건부)"></a>2. Predicate(조건부)</h4><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html" rel="external nofollow noopener noreferrer" target="_blank">Java 8 Function Predicate</a>를 사용</li><li>input 파라미터 타입은 <a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/server/ServerWebExchange.html" rel="external nofollow noopener noreferrer" target="_blank">Spring Framework ServerWebExchange</a></li><li>Predicate를 통해서 HTTP 요청의 대부분의 케이스에 대해서 매칭시킬 수가 있다. Request Header, Host, Method, Cookie, Path, Query 등등</li><li>SCG는 다양한 Route Predicate Factory를 탑재하고 있다.</li><li>여러 개 Predicate를 결합해서 사용할 수 있다.</li></ul><h4 id="3-Filter-필터"><a href="#3-Filter-필터" class="headerlink" title="3. Filter(필터)"></a>3. Filter(필터)</h4><ul><li>특정 팩토리로 구성된 <a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/server/GatewayFilter.html" rel="external nofollow noopener noreferrer" target="_blank">Spring Framework GatewayFilter</a> 인스턴스들</li><li>프록시 요청 전과 후로 Request와 Response를 수정할 수 있다.</li><li>SCG는 다양한 GatewayFilter Factory를 탑재하고 있다.</li><li>여러 개 GatewayFilter를 결합해서 사용할 수 있다.</li><li>좀 더 자세한 예제는 <a href="https://github.com/spring-cloud/spring-cloud-gateway/tree/master/spring-cloud-gateway-core/src/test/java/org/springframework/cloud/gateway/filter/factory" rel="external nofollow noopener noreferrer" target="_blank">Unit Tests</a>에서 볼 수 있다.</li></ul><h3 id="어떻게-사용하나"><a href="#어떻게-사용하나" class="headerlink" title="어떻게 사용하나?"></a>어떻게 사용하나?</h3><p>SCP는 Spring Boot Starter를 제공하며, SpringInitializr 에서 <code>Gateway</code>를 검색해서 dependency를 추가할 수가 있다.</p><p>Route 설정 방법은 간단한 예제로 설명한다.</p><ul><li>요청 Host가 <code>somehost.org</code> 또는 <code>anotherhost.org</code> 도메인이면(서브 도메인 포함)</li><li>요청 Header에 <code>X-Request-Red:Blue</code> 헤더를 추가하고 </li><li><code>http://httpbin.org</code> URI로 프록시 요청을 처리</li></ul><p>application.yml 설정으로 다음과 같이 간단하게 라우트를 설정할 수 있다.</p><figure class="highlight yaml"><figcaption><span>application.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">sample_host_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://httpbin.org</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Host=**.somehost.org,**.anotherhost.org</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=X-Request-Red,</span> <span class="string">Blue</span></span><br></pre></td></tr></table></figure><p>spring.cloud.gateway.routes 속성에 라우팅 정의를 리스트 단위로 설정할 수 있다.</p><ul><li>id: Route를 식별하기 위해 사용</li><li>uri: 프록시 요청할 서비스 URI</li><li>predicates: 조건부로 요청 Host의 매칭 패턴을 설정</li><li>filters: 필터로 요청 Header에 <code>X-Request-Red</code>를 추가하는 설정</li></ul><p>로컬에 애플리케이션을 구동하고 curl로 간단하게 요청을 보내보자.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl localhost:5000/get -H "Host: sub.somehost.org"</span><br></pre></td></tr></table></figure><p>아래는 httpbin.org<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>로 프록시 요청을 보내고 받은 응답이다.</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"args"</span>: &#123;&#125;, </span><br><span class="line">  <span class="attr">"headers"</span>: &#123;</span><br><span class="line">    <span class="attr">"Accept"</span>: <span class="string">"*/*"</span>, </span><br><span class="line">    <span class="attr">"Content-Length"</span>: <span class="string">"0"</span>, </span><br><span class="line">    <span class="attr">"Forwarded"</span>: <span class="string">"proto=http;host=sub.somehost.org;for=\"0:0:0:0:0:0:0:1:55265\""</span>, </span><br><span class="line">    <span class="attr">"Host"</span>: <span class="string">"httpbin.org"</span>, </span><br><span class="line">    <span class="attr">"User-Agent"</span>: <span class="string">"curl/7.64.1"</span>, </span><br><span class="line">    <span class="attr">"X-Amzn-Trace-Id"</span>: <span class="string">"Root=1-5e46010b-12079ee0a736019898c14ea0"</span>, </span><br><span class="line">    <span class="attr">"X-Forwarded-Host"</span>: <span class="string">"sub.somehost.org"</span>, </span><br><span class="line">    <span class="attr">"X-Request-Red"</span>: <span class="string">"Blue"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">"origin"</span>: <span class="string">"0:0:0:0:0:0:0:1, 211.174.55.156"</span>, </span><br><span class="line">  <span class="attr">"url"</span>: <span class="string">"http://sub.somehost.org/get"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>응답에 SCG가 httpbin.org로 보낸 요청 헤더들을 볼 수가 있는데 필터에 추가한 <code>X-Request-Red</code>가 보인다.</p><figure class="highlight plain"><figcaption><span>console</span></figcaption><table><tr><td class="code"><pre><span class="line">2020-02-14 11:08:11.616 DEBUG 46785 --- [ctor-http-nio-4] o.s.c.g.h.RoutePredicateHandlerMapping   : Route matched: sample_host_route</span><br><span class="line">2020-02-14 11:08:11.617 DEBUG 46785 --- [ctor-http-nio-4] o.s.c.g.h.RoutePredicateHandlerMapping   : Mapping [Exchange: GET http:&#x2F;&#x2F;sub.somehost.org&#x2F;get] to Route&#123;id&#x3D;&#39;sample_host_route&#39;, uri&#x3D;http:&#x2F;&#x2F;httpbin.org:80, order&#x3D;0, predicate&#x3D;Hosts: [**.somehost.org, **.anotherhost.org], gatewayFilters&#x3D;[[[AddRequestHeader X-Request-Red &#x3D; &#39;Blue&#39;], order &#x3D; 1]], metadata&#x3D;&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><p>로그를 보면 <code>sample_host_route</code> Route에 매치되었다고 나오고 다음 줄에는 세부적인 내용들이 나온다.</p><p>application 프로퍼티 외에 Java Configuration으로 설정이 가능하다.</p><p>아래는 application.yml에 설정한 것과 같은 처리를 한다.</p><figure class="highlight java"><figcaption><span>RouteConfiguration.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customRouteLocator</span><span class="params">(RouteLocatorBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.routes()</span><br><span class="line">            <span class="comment">// Sample</span></span><br><span class="line">            .route(<span class="string">"sample_host_route"</span>, r -&gt; r.host(<span class="string">"**.somehost.org,**.anotherhost.org"</span>)</span><br><span class="line">                    .filters(f -&gt; f.addRequestHeader(<span class="string">"X-Request-Red"</span>, <span class="string">"Blue"</span>))</span><br><span class="line">                    .uri(<span class="string">"http://httpbin.org"</span>))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 외에도 전체 Route에 공통으로 필터를 적용할 수 있는 Global Filter가 있다.</p><h3 id="커스터마이징은-가능한가"><a href="#커스터마이징은-가능한가" class="headerlink" title="커스터마이징은 가능한가?"></a>커스터마이징은 가능한가?</h3><p>Yes! Predicate, GatewayFilter에 대해서 커스텀이 가능하다.</p><p>아래에 개발자를 위한 가이드 링크가 있다.</p><ul><li><a href="https://cloud.spring.io/spring-cloud-gateway/reference/html/#writing-custom-route-predicate-factories" rel="external nofollow noopener noreferrer" target="_blank">17.1. Writing Custom Route Predicate Factories</a></li><li><a href="https://cloud.spring.io/spring-cloud-gateway/reference/html/#writing-custom-gatewayfilter-factories" rel="external nofollow noopener noreferrer" target="_blank">17.2. Writing Custom GatewayFilter Factories</a></li><li><a href="https://cloud.spring.io/spring-cloud-gateway/reference/html/#writing-custom-global-filters" rel="external nofollow noopener noreferrer" target="_blank">17.3. Writing Custom Global Filters</a></li></ul><p>요청 IP에 대한 화이트리스트 제어를 Global Filter를 만들어서 적용해 봤는데 잘 되었다.<br>GlobalFilter를 구현한 클래스를 만들고 Configuration에 빈으로 추가하면 된다.<br>아래에 만든 코드가 있으니 자세한 설명은 생략한다.</p><figure class="highlight java"><figcaption><span>GlobalFilterConfiguration.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalFilterConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GlobalFilter <span class="title">whitelistGlobalFilter</span><span class="params">(WhitelistChecker whitelistChecker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WhitelistGlobalFilter(whitelistChecker);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>WhitelistGlobalFilter.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhitelistGlobalFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WhitelistChecker whitelistChecker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhitelistGlobalFilter</span><span class="params">(WhitelistChecker whitelistChecker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.whitelistChecker = whitelistChecker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// verify request remote address</span></span><br><span class="line">        String remoteAddress = getRemoteAddress(exchange);</span><br><span class="line">        <span class="keyword">if</span> (whitelistChecker.blocked(remoteAddress)) &#123;</span><br><span class="line">            ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">            response.setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">            <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getRemoteAddress</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">        RemoteAddressResolver resolver = XForwardedRemoteAddressResolver.maxTrustedIndex(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> resolver.resolve(exchange).getAddress().getHostAddress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="운영-환경에서-사용할만-한가"><a href="#운영-환경에서-사용할만-한가" class="headerlink" title="운영 환경에서 사용할만 한가?"></a>운영 환경에서 사용할만 한가?</h3><p>이 부분은 실제 운영 환경에서 풀어나가야 할 숙제이다.<br>실제 운영환경에서 사용하려면 성능, 안정성, 운영 등에 대한 여러가지 요건이 필요하기 때문에 요건을 도출하고 실행 및 테스트를 진행해야 한다.</p><p>기회가 되면 이 부분에 대해서 정리해 보고자 한다.</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">유지보수 대상 모듈: archaius, hystrix-contract, hystrix-dashboard, hystrix-stream, hystrix, ribbon, turbine-stream, turbine, zuul</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">모듈을 유지보수 모드로 설정하면 스프링 클라우드 팀은 모듈에 새로운 기능을 추가하지 않고, 버그 및 보안 문제를 해결하고, 커뮤니티의 작은 PR만 검토한다.</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">횡단 관심사(cross cutting concerns): 애플리케이션에서 로깅, 트랜잭션, 보안과 같이 다수의 모듈에서 반복적으로 나타나는 부분이 존재하는데 이것을 횡단 관심사 라고 한다.</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">피보탈의 오픈소스 프로젝트로 JVM에서 동작하는 Non-blocking 애플리케이션을 만들기 위한 리액티브 라이브러리</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">httpbin.org는 Request 내용을 JSON 응답으로 보내주기 때문에 HTTP 테스트용으로 사용하는 서비스</span><a href="#fnref:5" rev="footnote"> ↩</a></li></ol></div></div>]]></content:encoded>
      
      <comments>https://wellstyle.github.io/2020/04/10/Spring-Cloud-Gateway/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Close To You - Carpenters</title>
      <link>https://wellstyle.github.io/2020/04/07/Close-To-You-Carpenters/</link>
      <guid>https://wellstyle.github.io/2020/04/07/Close-To-You-Carpenters/</guid>
      <pubDate>Tue, 07 Apr 2020 12:48:04 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;Just like me, they long to be close to you&lt;br&gt;나처럼, 그들도 당신 곁에 머물고 싶은가 봐요&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/oaOyoVS-IAI&quot; frameborder=&quot;0&quot; loading=&quot;lazy&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>Just like me, they long to be close to you<br>나처럼, 그들도 당신 곁에 머물고 싶은가 봐요</p></blockquote><div class="video-container"><iframe src="https://www.youtube.com/embed/oaOyoVS-IAI" frameborder="0" loading="lazy" allowfullscreen></iframe></div><a id="more"></a><h3 id="Couch-Choir-They-Long-To-Be-Close-To-You"><a href="#Couch-Choir-They-Long-To-Be-Close-To-You" class="headerlink" title="Couch Choir - (They Long To Be) Close To You"></a>Couch Choir - (They Long To Be) Close To You</h3><blockquote><p>Pub Choir 채널에서는 “Close To You” 노래하는 영상을 모집했고 단 이틀만에 18개 나라의 1000명 이상의 사람들이 영상을 제출했다. </p></blockquote><div class="video-container"><iframe src="https://www.youtube.com/embed/HezxInuN1YA" frameborder="0" loading="lazy" allowfullscreen></iframe></div>]]></content:encoded>
      
      <comments>https://wellstyle.github.io/2020/04/07/Close-To-You-Carpenters/#disqus_thread</comments>
    </item>
    
    <item>
      <title>재택근무를 위한 업무용 데스크 구성</title>
      <link>https://wellstyle.github.io/2020/04/04/%EC%9E%AC%ED%83%9D%EA%B7%BC%EB%AC%B4%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%97%85%EB%AC%B4%EC%9A%A9-%EB%8D%B0%EC%8A%A4%ED%81%AC-%EA%B5%AC%EC%84%B1/</link>
      <guid>https://wellstyle.github.io/2020/04/04/%EC%9E%AC%ED%83%9D%EA%B7%BC%EB%AC%B4%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%97%85%EB%AC%B4%EC%9A%A9-%EB%8D%B0%EC%8A%A4%ED%81%AC-%EA%B5%AC%EC%84%B1/</guid>
      <pubDate>Sat, 04 Apr 2020 16:03:46 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;재택근무&quot;&gt;&lt;a href=&quot;#재택근무&quot; class=&quot;headerlink&quot; title=&quot;재택근무&quot;&gt;&lt;/a&gt;재택근무&lt;/h2&gt;&lt;p&gt;코로나19로 인해 2월 마지막 주부터 재택근무를 시작했다.&lt;/p&gt;
&lt;p&gt;재택근무 이전에는 서재에 책상과 간이 의자만 있고 흔한 모니터 하나 없었다. 하지만 업무가 시작되면서 불편한 게 한두 가지가 아니었고, 필요한 것부터 하나하나 장만하다 보니 지금의 모습을 갖추게 되었다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="재택근무"><a href="#재택근무" class="headerlink" title="재택근무"></a>재택근무</h2><p>코로나19로 인해 2월 마지막 주부터 재택근무를 시작했다.</p><p>재택근무 이전에는 서재에 책상과 간이 의자만 있고 흔한 모니터 하나 없었다. 하지만 업무가 시작되면서 불편한 게 한두 가지가 아니었고, 필요한 것부터 하나하나 장만하다 보니 지금의 모습을 갖추게 되었다.</p><a id="more"></a><h2 id="데스크-구성"><a href="#데스크-구성" class="headerlink" title="데스크 구성"></a>데스크 구성</h2><p><img src="/gallery/2020/04/home-desk.png" alt="서재의 책상 사진"></p><h3 id="책상"><a href="#책상" class="headerlink" title="책상"></a>책상</h3><p><code>데스커 모션 데스크</code></p><p>스위치로 간편하게 높이 조절을 할 수가 있어서 앉거나 서서 일할 수 있다. 일하다가 몸이 뻐근해질 때가 있는데 잠시 책상 높이를 올리고 서서 업무를 진행하는 용도로 사용한다. 책상 앞쪽 하단에 멀티탭과 전선들을 수납할 수 있는 보이지 않는 선반이 있어서 책상 위가 깔끔해진다.</p><h3 id="노트북"><a href="#노트북" class="headerlink" title="노트북"></a>노트북</h3><p><code>애플 MacBook Pro (15인치, 2017)</code></p><p>회사에서 사용하고 있는 노트북으로 회사에서 가져온 유일한 구성품이기도 하다.</p><h3 id="키보드"><a href="#키보드" class="headerlink" title="키보드"></a>키보드</h3><p><code>레오폴드 FC750R</code></p><p>집에서 쓰려고 작년에 중고로 구매하고 사용 빈도가 적었는데 이번에 아주 유용하게 사용하고 있다.</p><h3 id="모니터"><a href="#모니터" class="headerlink" title="모니터"></a>모니터</h3><p><code>LG 32QK500C</code></p><p>노트북 15인치 화면 하나로 업무를 처리하기엔 효율이 떨어져서 모니터가 하나 필요했다. 책상 면적이 넓은 편이 아니어서 모니터를 1대만 놓을 거라 24인치보다는 32인치로 골랐고 4K보다는 QHD(2560 x 1440)가 글씨 크기가 적당하게 보일 거 같았다. 모니터 암에 설치할 거라 월 마운트 가능한 모델로 선택했다.</p><p>처음엔 크기가 커서 적응이 안 되었는데 차츰 윈도우 크기와 배치를 조절하며 적응해 가고 있다.</p><h3 id="모니터-암"><a href="#모니터-암" class="headerlink" title="모니터 암"></a>모니터 암</h3><p><code>카멜마운트 PMA-2U</code></p><p>높낮이 조절 책상을 쓰다 보니 모니터 스탠드보다는 암을 쓰는 게 적합할 거라 생각했고 32인치에 맞는 모델을 찾아서 구매했는데 높이 조절, 틸트, 피벗까지 가능하고 케이블이 보이지 않게 덮개가 있어서 선 정리도 깔끔하게 되었다.</p><h3 id="도킹-스테이션"><a href="#도킹-스테이션" class="headerlink" title="도킹 스테이션"></a>도킹 스테이션</h3><p><code>벤션 USB 타입 C 허브 9 in 1</code></p><p>맥북에 USB 타입 C 포트만 있기 때문에 모니터와 키보드를 연결하려면 각자 타입 C 케이블이 필요하고 포트마다 연결해야 해서 깔끔하지가 않다. 그래서 허브 하나로 전원, HDMI, USB 연결을 할 수 있는 것으로 구매</p><h3 id="스피커"><a href="#스피커" class="headerlink" title="스피커"></a>스피커</h3><p><code>오디오엔진 A2+ Wireless</code></p><p>업무에 꼭 필요한 건 아니지만 예전부터 PC-Fi 용으로 사고 싶었던 모델이기도 하고 좋은 음악과 음질로 자신을 힐링하기 위해 구매하였다. 노트북 + 모니터 + 스피커 조합으로 영화나 유튜브 보기에도 너무 좋다. </p><p>입력은 AUX, USB, 블루투스(aptX-LL 지원) 3가지 동시에 지원해서 활용도가 높다.</p><h3 id="트랙패드"><a href="#트랙패드" class="headerlink" title="트랙패드"></a>트랙패드</h3><p><code>애플 Magic TrackPad 2</code></p><p>맥을 제대로 쓰려면 마우스보다는 트랙패드 추천. 손목이나 손가락 관절에 무리가 덜 간다.</p><h3 id="AI-스피커"><a href="#AI-스피커" class="headerlink" title="AI 스피커"></a>AI 스피커</h3><p><code>구글 홈 미니</code></p><p>날씨 물어보고 아침 뉴스 듣는 용도로 쓰고 있다. 음악, 영화 감상용 스피커로는 비추</p><h3 id="의자"><a href="#의자" class="headerlink" title="의자"></a>의자</h3><p><code>에이픽스 GC001 ARGENTINA</code></p><p>스탠딩 책상이 있어서 의자가 불편해도 괜찮겠다 생각했는데 등받이 없는 간이 의자로는 역시 무리가 있었다. 특히 목과 어깨 통증이 심해져서 의자를 알아봤다. 딱히 사고 싶은 후보가 없었는데 회사 동료 추천으로 알아보다가 가성비와 디자인이 괜찮고 팔걸이 조절되는 것이 맘에 들어서 구매했다.</p><p>의자가 바뀌니 어깨와 목 통증이 줄어들었다. 가장 빨리 구매했어야 하는 품목이 의자인데 실상은 가장 늦게 구매한 품목이 됐다.</p><h2 id="총평"><a href="#총평" class="headerlink" title="총평"></a>총평</h2><p>재택근무 한 달만에 완성이 되긴 했지만 지금의 데스크 구성이 꽤나 맘에 든다. 단 기간에 지출은 좀 있었지만 재택근무가 아니더라도 집에서 공부하거나 음악, 영상을 감상하는 공간으로 활용할 거라 적당한 투자라고 생각한다.</p>]]></content:encoded>
      
      <comments>https://wellstyle.github.io/2020/04/04/%EC%9E%AC%ED%83%9D%EA%B7%BC%EB%AC%B4%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%97%85%EB%AC%B4%EC%9A%A9-%EB%8D%B0%EC%8A%A4%ED%81%AC-%EA%B5%AC%EC%84%B1/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
